---
title: "V8"
date: 2025-08-02T13:13:14+08:00
draft: false
description: V8以及浏览器总结
toc: true
authors:
  - example-author
tags:
  - V8
  - 浏览器
categories:
    - V8
    - 浏览器
    - 前端
---


### V8内存架构（C++）

![V8架构]()

* code space：储存及时编译后的代码

* new space：64MB 垃圾回收重点

* old space：1400MB 垃圾回收重点

* node整个内存：1.4GB/2GB

JS引擎包含一个`调用栈`和一个`堆`

* 调用栈 — 程序执行的内存空间

* 堆 — 存储对象的内存空间

### 内存泄漏

![]()

有些内存无法被垃圾回收器回收，这部分内存叫做内存泄漏

### 垃圾回收器机制

* 标记清除（目前主流）具体概念可以MDN

* 引用计数

浏览器知道哪些`内存无法触达`，垃圾回收器就会自动触发执行给回收掉

若有些内存能触达，但实际上不会再用，就需要`手动处理`，让这些内存无法触达

```javascript
let obj = {
  users : "lf"
}
obj = null
```

### 浏览器架构

![]()

### 浏览器进程

JS是单线程，浏览器是多进程和多线程，二者并不冲突

![](images/diagram.png)

* 浏览器进程

  * 地址栏、书签、前进、后退、网络请求和文件访问

  * UI线程

  * 标签页创建和销毁

  * 网络线程

  * 存储线程

* 渲染进程(也叫浏览器内核)

  * 渲染线程：Blink线程负责渲染HTML和CSS；重绘（颜色变化）、重排（HTML布局变化）

  * JS解释器线程 （V8）

    * 执行JS

    * 与GUI渲染线程`互斥`

  * 定时器触发线程

  * 事件触发线程

  * 异步HTTP线程

  * &#x20;Worker线程

    * 位于渲染进程内

    * 一些复杂计算可以交给Worker线程，避免影响V8线程渲染

    * 不能操作DOM

    * 与`JS线程`通过`postMessage`通信

  * 合成器线程

  * 光栅线程

* 插件进程

* 工具进程

* GPU进程

### 浏览器详解博客

[深入了解现代网络浏览](https://juejin.cn/post/6985406475493441566)

### JS引擎和JS运行时

![]()

JS引擎：编译、解析、优化、执行

![]()

### 堆与栈

AST抽象语法树之后hashMap会缓存所有字符串

* 堆：其它类型、字符串、大整数、小数

* 栈：小的整数存在栈中

### V8及时编译

![]()

* 解析器 转换成AST语法树

* 转换器 AST到字节码&执行

* 编译器 `及时优化`功能体现 — Turbofan :优化`Hot Function`代码，缓存为机器码

### 运行时

`运行时 = JS引擎 + 事件处理 + 网络请求 + 回调队列 + 事件循环`

![]()

### 企业级JS运行时

阿里：aliNode 基于nodeJS，扩展了性能监控、安全提醒、故障排除、性能优化

### 企业级包管理器

tnpm 腾讯

### 渲染进程

[渲染进程](https://juejin.cn/post/6986836031345524743)

* Blink渲染线程解析HTML HTML -> DOM

* 预加载扫描器并行请求CSS和图片

* JS资源会阻止Blink渲染线程执行，使用async/defer异步加载资源

* Blink渲染线程解析CSS

* 得到渲染树（包括了XY坐标） 通过DOM和计算样式

* 绘制 考虑z-index

* 合成

### 渲染流程

1. 构建DOM树。HTML内容转为DOM树

2. 样式计算。css内容转换为styleSheets对象，属性值标准化rem转px，不显示的DOM节点去掉，设置为display:none的节点会存在DOM树里。将三种CSS文件样式**属性值标准化**。计算出每个元素的最终样式

   * display:none不在布局树中

   * visibility：hidden在布局树

   * 伪类在布局树

3. 布局阶段。有了DOM树和DOM样式，计算出**可见元素的几何位置**。chrome创建布局树和布局树节点的几何位置。一般默认**流式布局**方式，除了这种布局方式，还有**定位布局和浮动布局**

4. 分层 有些节点比较特殊，比如有立体效果。因此还需要一个图层树

5) 图层说明 <https://pcaaron.github.io/pages/fe/chrome/drawing.html#%E5%88%86%E5%B1%82>

6) 绘制。对每个图层得到`绘制指令`，最终产出一个绘制列表

7) 分块。图层分为很多图块。会优先生成视口附近的图块

8) 光栅化和合成。将图块 -> 位图。GPU参与珊格化

![]()

### 输入URL过程

1. **浏览器进程** 组装协议；

2. 浏览器进程 将URL协议 给**网络进程**；

3. 网络进程将在本地缓存检查是否缓存请求的资源，如有，则返回给浏览器进程；

4. 如没有，网络进程发送HTTP请求给Web服务器

   * 进行DNS解析，获取服务器IP地址

   * 利用IP地址和服务器建立TCP连接

   * 构建请求头

   * 发送请求头

   * 服务器响应后，网络进程接收响应头和响应信息

5. 网络进程解析响应

   * 检查状态码，如果是301或者302，需要重定向，从Location读取地址，如果是304的话，从缓存中拿资源。重新进行第3步

   * 如果是200，检查content-type，如果是**字节流**类型，则提交给下载进程；如果是HTML，则通知浏览器进程，准备渲染

6. 渲染进程。浏览器进程检查当前url和之前已经打开的渲染进程url是否相同，如果相同则复用原来进程；不同，则开启新的渲染进程

![]()

